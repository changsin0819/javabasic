<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>리터럴 함수</title>
</head>
<body>
	<script>

	// [ 호이스팅 개념을 모르는 경우 ]
	// @ function 명령은 정적인 구조이다. 함수호출보다 앞에있으나 뒤에있으나 실행됨 
	// @ 함수리터럴과 화살표함수는 실행시 판단한다. 함수호출보다 뒤에있으면 에러
	// ***** [결론] javascript의 함수 선언은 호출보다 무조건 앞에 하기!
	
	/*  
		호이스팅( hoistion : 끌어올리다 )
	*/
	
	/* 
	document.writeln('1. 삼각형의 면적은 : ' +  triangle(4,3) + '<br/>');
	function triangle ( base, height )
	{
		return base * height / 2;
	} 
	*/
	
	/* 
	document.writeln('삼각형의 면적은 2 : ' +  triangle2(4,3) + '<br/>');		
	
	var triangle2 = function( base, height ){
		return base * height / 2;
	} 
	*/
	
	
	// @ 함수는 데이터형의 일종이다. => 함수 리터럴 : 변수의 값
/* 	let triangle = function( base, height ) {
												return base * height / 2;
											}
	document.writeln('삼각형의 면적은 2 : ' +  triangle(4,3) + '<br/>');
	
	document.writeln('함수 : '+ triangle + '<hr/>' );
	
	triangle = '문자로 변환';
	
	document.writeln('문자 : '+ triangle + '<hr/>' );
	
	triangle = 19090;
	
	document.writeln('숫자 : '+ triangle + '<hr/>' ); */
	
	/* function doA()
	{
		document.writeln('함수 A 실행<br/>');
	}
	
	function doB()
	{
		document.writeln('함수 B 실행<br/>');
	}
	
	let arr = [doA, doB];	// 함수가 배열의 인자가 될 수 있다.
	//console.log(arr);
	
	arr[0](); 	// doA();
	arr[1](); 	// doB();
 */
 	
 	// @ 함수가 함수의 인자가 될 수 있다
 	
 	/* let f1 = function(){ return 2; };			
 	let f2 = function(){ return 1; };
 	let f3 = function(a){ return a*a; };
 	
 	//document.writeln(f1 + '<br/>');
 	
 	function f4(x, y, z) {
 		// 함수를 인자로 받으면 리턴값도 함수처리를 해줘야된다
 		return z( x()+y() )
 	}
 	
 	let result = f4(f1, f2, f3);
    document.write ('결과 : ' + result); */
 
 	function f4(x, y, z) {
 		// 함수를 인자로 받으면 리턴값도 함수처리를 해줘야된다
 		return z( x()+y() )
    }
    
    let result = f4(
    				 function(){ return 2; },
    				 function(){ return 1; },
    				 function(a){ return a*a; }
    			    );
    document.write ('결과 : ' + result);
    
    
	</script>
</body>
</html>